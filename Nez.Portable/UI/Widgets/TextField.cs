using System;
using Nez.BitmapFonts;
using Microsoft.Xna.Framework;
using System.Text;
using System.Collections.Generic;
using Microsoft.Xna.Framework.Input;


namespace Nez.UI
{
	/// <summary>
	/// A single-line text input field.
	/// 
	/// The preferred height of a text field is the height of the {@link TextFieldStyle#font} and {@link TextFieldStyle#background}.
	/// The preferred width of a text field is 150, a relatively arbitrary size.
	/// 
	/// The text field will copy the currently selected text when ctrl+c is pressed, and paste any text in the clipboard when ctrl+v is
	/// pressed. Clipboard functionality is provided via the {@link Clipboard} interface.
	/// 
	/// The text field allows you to specify an {@link OnscreenKeyboard} for displaying a softkeyboard and piping all key events
	/// generated by the keyboard to the text field. There are two standard implementations, one for the desktop and one for Android.
	/// The desktop keyboard is a stub, as a softkeyboard is not needed on the desktop. The Android {@link OnscreenKeyboard}
	/// implementation will bring up the default IME.
	/// </summary>
	public class TextField : Element, IInputListener, IKeyboardListener
	{
		public event Action<TextField,string> OnTextChanged;

		public override float PreferredWidth
		{
			get { return _preferredWidth; }
		}

		public override float PreferredHeight
		{
			get
			{
				var prefHeight = TextHeight;
				if( _style.Background != null )
					prefHeight = Math.Max( prefHeight + _style.Background.BottomHeight + _style.Background.TopHeight, _style.Background.MinHeight );

				return prefHeight;
			}
		}

		/// <summary>
		/// the maximum distance outside the TextField the mouse can move when pressing it to cause it to be unfocused
		/// </summary>
		public float TextFieldBoundaryThreshold = 100f;

		/// <summary>
		/// if true and setText is called it will be ignored
		/// </summary>
		public bool ShouldIgnoreTextUpdatesWhileFocused = true;

		protected string Text;
		protected int Cursor, SelectionStart;
		protected bool HasSelection;
		protected bool WriteEnters;
		List<float> _glyphPositions = new List<float>( 15 );

		float _preferredWidth = 150;
		TextFieldStyle _style;
		string _messageText;
		protected string DisplayText = string.Empty;
		ITextFieldFilter _filter;
		bool _focusTraversal = true, _onlyFontChars = true, _disabled;
		int _textHAlign = AlignInternal.Left;
		float _selectionX, _selectionWidth;
		StringBuilder _textBuffer = new StringBuilder();

		bool _passwordMode;
		StringBuilder _passwordBuffer;
		char _passwordCharacter = '*';

		protected float FontOffset, TextHeight, TextOffset;
		float _renderOffset;
		int _visibleTextStart, _visibleTextEnd;
		int _maxLength = 0;

		float _blinkTime = 0.5f;
		bool _cursorOn = true;
		float _lastBlink;

		bool _programmaticChangeEvents;

		protected bool _isOver, _isPressed, _isFocused;
		ITimer _keyRepeatTimer;
		float _keyRepeatTime = 0.2f;


		public TextField( string text, TextFieldStyle style )
		{
			SetStyle( style );
			SetText( text );
			SetSize( PreferredWidth, PreferredHeight );
		}


		public TextField( string text, Skin skin, string styleName = null ) : this( text, skin.Get<TextFieldStyle>( styleName ) )
		{}


		#region IInputListener

		float _clickCountInterval = 0.2f;
		int _clickCount;
		float _lastClickTime;

		void IInputListener.OnMouseEnter()
		{
			_isOver = true;
		}


		void IInputListener.OnMouseExit()
		{
			_isOver = _isPressed = false;
		}


		bool IInputListener.OnMousePressed( Vector2 mousePos )
		{
			if( _disabled )
				return false;

			_isPressed = true;
			SetCursorPosition( mousePos.X, mousePos.Y );
			SelectionStart = Cursor;
			HasSelection = true;
			var stage = GetStage();
			if( stage != null )
				stage.SetKeyboardFocus( this as IKeyboardListener );

			return true;
		}


		void IInputListener.OnMouseMoved( Vector2 mousePos )
		{
			if( DistanceOutsideBoundsToPoint( mousePos ) > TextFieldBoundaryThreshold )
			{
				_isPressed = _isOver = false;
				GetStage().RemoveInputFocusListener( this );
			}
			else
			{
				SetCursorPosition( mousePos.X, mousePos.Y );
			}
		}


		void IInputListener.OnMouseUp( Vector2 mousePos )
		{
			if( SelectionStart == Cursor )
				HasSelection = false;
			
			if( Time.time - _lastClickTime > _clickCountInterval )
				_clickCount = 0;
			_clickCount++;
			_lastClickTime = Time.time;
			_isPressed = _isOver = false;
		}


		bool IInputListener.OnMouseScrolled( int mouseWheelDelta )
		{
			return false;
		}

		#endregion


		#region IKeyboardListener

		void IKeyboardListener.KeyDown( Keys key )
		{
			if( _disabled )
				return;

			_lastBlink = 0;
			_cursorOn = false;

			var isCtrlDown = InputUtils.IsControlDown();
			var jump = isCtrlDown && !_passwordMode;
			var repeat = false;

			if( isCtrlDown )
			{
				if( key == Keys.V )
				{
					Paste( Clipboard.GetContents(), true );
				}
				else if( key == Keys.C || key == Keys.Insert )
				{
					Copy();
					return;
				}
				else if( key == Keys.X )
				{
					Cut( true );
					return;
				}
				else if( key == Keys.A )
				{
					SelectAll();
					return;
				}
			}

			if( InputUtils.IsShiftDown() )
			{
				if( key == Keys.Insert )
					Paste( Clipboard.GetContents(), true );
				else if( key == Keys.Delete )
					Cut( true );

				// jumping around shortcuts
				var temp = Cursor;
				var foundJumpKey = true;

				if( key == Keys.Left )
				{
					MoveCursor( false, jump );
					repeat = true;
				}
				else if( key == Keys.Right )
				{
					MoveCursor( true, jump );
					repeat = true;
				}
				else if( key == Keys.Home )
				{
					GoHome();
				}
				else if( key == Keys.End )
				{
					GoEnd();
				}
				else
				{
					foundJumpKey = false;
				}

				if( foundJumpKey && !HasSelection )
				{
					SelectionStart = temp;
					HasSelection = true;
				}
			}
			else
			{
				// Cursor movement or other keys (kills selection)
				if( key == Keys.Left )
				{
					MoveCursor( false, jump );
					ClearSelection();
					repeat = true;
				}
				else if( key == Keys.Right )
				{
					MoveCursor( true, jump );
					ClearSelection();
					repeat = true;
				}
				else if( key == Keys.Home )
				{
					GoHome();
				}
				else if( key == Keys.End )
				{
					GoEnd();
				}
			}

			Cursor = Mathf.Clamp( Cursor, 0, Text.Length );

			if( repeat )
			{
				if( _keyRepeatTimer != null )
					_keyRepeatTimer.Stop();
				_keyRepeatTimer = Core.Schedule( _keyRepeatTime, true, this, t => ( t.Context as IKeyboardListener ).KeyDown( key ) );
			}
		}


		void IKeyboardListener.KeyPressed( Keys key, char character )
		{
			if( InputUtils.IsControlDown() )
				return;

			// disallow typing most ASCII control characters, which would show up as a space
			switch ( key )
			{
				case Keys.Back:
				case Keys.Delete:
				case Keys.Tab:
				case Keys.Enter:
				break;
				default:
					{
						if( (int)character < 32 )
							return;
						break;
					}
			}

			if( key == Keys.Tab && _focusTraversal )
			{
				Next( InputUtils.IsShiftDown() );
			}
			else
			{
				var enterPressed = key == Keys.Enter;
				var backspacePressed = key == Keys.Back;
				var deletePressed = key == Keys.Delete;
				var add = enterPressed ? WriteEnters : ( !_onlyFontChars || _style.Font.HasCharacter( character ) );
				var remove = backspacePressed || deletePressed;

				if( add || remove )
				{
					var oldText = Text;
					if( HasSelection )
					{
						Cursor = Delete( false );
					}
					else
					{
						if( backspacePressed && Cursor > 0 )
						{
							Text = Text.Substring( 0, Cursor - 1 ) + Text.Substring( Cursor-- );
							_renderOffset = 0;
						}

						if( deletePressed && Cursor < Text.Length )
						{
							Text = Text.Substring( 0, Cursor ) + Text.Substring( Cursor + 1 );
						}
					}

					if( add && !remove )
					{
						// character may be added to the text.
						if( !enterPressed && _filter != null && !_filter.AcceptChar( this, character ) )
							return;

						if( !WithinMaxLength( Text.Length ) )
							return;
						
						var insertion = enterPressed ? "\n" : character.ToString();
						Text = Insert( Cursor++, insertion, Text );
					}

					ChangeText( oldText, Text );
					UpdateDisplayText();
				}
			}
		}


		void IKeyboardListener.KeyReleased( Keys key )
		{
			if( _keyRepeatTimer != null )
			{
				_keyRepeatTimer.Stop();
				_keyRepeatTimer = null;
			}
		}


		void IKeyboardListener.GainedFocus()
		{
			HasSelection = _isFocused = true;
		}


		void IKeyboardListener.LostFocus()
		{
			HasSelection = _isFocused = false;
			if( _keyRepeatTimer != null )
			{
				_keyRepeatTimer.Stop();
				_keyRepeatTimer = null;
			}
		}

		#endregion


		protected int LetterUnderCursor( float x )
		{
			var halfSpaceSize = _style.Font.SpaceWidth;
			x -= TextOffset + FontOffset + halfSpaceSize /*- style.font.getData().cursorX*/ - _glyphPositions[_visibleTextStart];
			var n = _glyphPositions.Count;
			for( var i = 0; i < n; i++ )
			{
				if( _glyphPositions[i] > x && i >= 1 )
				{
					if( _glyphPositions[i] - x <= x - _glyphPositions[i - 1] )
						return i;
					return i - 1;
				}
			}
			return n - 1;
		}


		protected bool IsWordCharacter( char c )
		{
			return ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || ( c >= '0' && c <= '9' );
		}


		protected int[] WordUnderCursor( int at )
		{
			int start = at, right = Text.Length, left = 0, index = start;
			for(; index < right; index++ )
			{
				if( !IsWordCharacter( Text[index] ) )
				{
					right = index;
					break;
				}
			}
			for( index = start - 1; index > -1; index-- )
			{
				if( !IsWordCharacter( Text[index] ) )
				{
					left = index + 1;
					break;
				}
			}
			return new int[] { left, right };
		}


		int[] WordUnderCursor( float x )
		{
			return WordUnderCursor( LetterUnderCursor( x ) );
		}


		bool WithinMaxLength( int size )
		{
			return _maxLength <= 0 || size < _maxLength;
		}


		public TextField SetMaxLength( int maxLength )
		{
			this._maxLength = maxLength;
			return this;
		}


		public int GetMaxLength()
		{
			return this._maxLength;
		}


		/// <summary>
		/// When false, text set by {@link #setText(String)} may contain characters not in the font, a space will be displayed instead.
		/// When true (the default), characters not in the font are stripped by setText. Characters not in the font are always stripped
		/// when typed or pasted.
		/// </summary>
		/// <param name="onlyFontChars">If set to <c>true</c> only font chars.</param>
		public TextField SetOnlyFontChars( bool onlyFontChars )
		{
			this._onlyFontChars = onlyFontChars;
			return this;
		}


		public TextField SetStyle( TextFieldStyle style )
		{
			this._style = style;
			TextHeight = style.Font.LineHeight;
			InvalidateHierarchy();
			return this;
		}


		/// <summary>
		/// Returns the text field's style. Modifying the returned style may not have an effect until {@link #setStyle(TextFieldStyle)} is called
		/// </summary>
		/// <returns>The style.</returns>
		public TextFieldStyle GetStyle()
		{
			return _style;
		}


		protected void CalculateOffsets()
		{
			float visibleWidth = GetWidth();
			if( _style.Background != null )
				visibleWidth -= _style.Background.LeftWidth + _style.Background.RightWidth;

			var glyphCount = _glyphPositions.Count;

			// Check if the cursor has gone out the left or right side of the visible area and adjust renderoffset.
			var distance = _glyphPositions[Math.Max( 0, Cursor - 1 )] + _renderOffset;
			if( distance <= 0 )
			{
				_renderOffset -= distance;
			}
			else
			{
				var index = Math.Min( glyphCount - 1, Cursor + 1 );
				var minX = _glyphPositions[index] - visibleWidth;
				if( -_renderOffset < minX )
				{
					_renderOffset = -minX;
				}
			}

			// calculate first visible char based on render offset
			_visibleTextStart = 0;
			var startX = 0f;
			for( var i = 0; i < glyphCount; i++ )
			{
				if( _glyphPositions[i] >= -_renderOffset )
				{
					_visibleTextStart = Math.Max( 0, i );
					startX = _glyphPositions[i];
					break;
				}
			}

			// calculate last visible char based on visible width and render offset
			var length = DisplayText.Length;
			_visibleTextEnd = Math.Min( length, Cursor + 1 );
			for(; _visibleTextEnd <= length; _visibleTextEnd++ )
				if( _glyphPositions[_visibleTextEnd] > startX + visibleWidth )
					break;
			_visibleTextEnd = Math.Max( 0, _visibleTextEnd - 1 );

			if( ( _textHAlign & AlignInternal.Left ) == 0 )
			{
				TextOffset = visibleWidth - ( _glyphPositions[_visibleTextEnd] - startX );
				if( ( _textHAlign & AlignInternal.Center ) != 0 )
					TextOffset = Mathf.Round( TextOffset * 0.5f );
			}
			else
			{
				TextOffset = startX + _renderOffset;
			}

			// calculate selection x position and width
			if( HasSelection )
			{
				var minIndex = Math.Min( Cursor, SelectionStart );
				var maxIndex = Math.Max( Cursor, SelectionStart );
				var minX = Math.Max( _glyphPositions[minIndex], -_renderOffset );
				var maxX = Math.Min( _glyphPositions[maxIndex], visibleWidth - _renderOffset );
				_selectionX = minX;

				if( _renderOffset == 0 )
					_selectionX += TextOffset;

				_selectionWidth = maxX - minX;
			}
		}


		#region Drawing

		public override void Draw( Graphics graphics, float parentAlpha )
		{
			var font = _style.Font;
			var fontColor = ( _disabled && _style.DisabledFontColor.HasValue ) ? _style.DisabledFontColor.Value
				: ( ( _isFocused && _style.FocusedFontColor.HasValue ) ? _style.FocusedFontColor.Value : _style.FontColor );
			IDrawable selection = _style.Selection;
			IDrawable background = ( _disabled && _style.DisabledBackground != null ) ? _style.DisabledBackground
				: ( ( _isFocused && _style.FocusedBackground != null ) ? _style.FocusedBackground : _style.Background );

			var color = GetColor();
			var x = GetX();
			var y = GetY();
			var width = GetWidth();
			var height = GetHeight();

			float bgLeftWidth = 0, bgRightWidth = 0;
			if( background != null )
			{
				background.Draw( graphics, x, y, width, height, new Color( color, color.A * parentAlpha ) );
				bgLeftWidth = background.LeftWidth;
				bgRightWidth = background.RightWidth;
			}

			var textY = GetTextY( font, background );
			var yOffset = (textY < 0) ? -textY - font.LineHeight/2 + PreferredWidth / 2  : 0;
			CalculateOffsets();

			if( _isFocused && HasSelection && selection != null )
				DrawSelection( selection, graphics, font, x + bgLeftWidth, y + textY + yOffset );

			if( DisplayText.Length == 0 )
			{
				if( !_isFocused && _messageText != null )
				{
					var messageFontColor = _style.MessageFontColor.HasValue ? _style.MessageFontColor.Value : new Color( 180, 180, 180, color.A * parentAlpha );
					var messageFont = _style.MessageFont != null ? _style.MessageFont : font;
					graphics.Batcher.DrawString( messageFont, _messageText, new Vector2( x + bgLeftWidth, y + textY + yOffset ), messageFontColor );
					//messageFont.draw( graphics.batcher, messageText, x + bgLeftWidth, y + textY + yOffset, 0, messageText.length(),
					//	width - bgLeftWidth - bgRightWidth, textHAlign, false, "..." );
				}
			}
			else
			{
				var col = new Color( fontColor, fontColor.A * parentAlpha );
				var t = DisplayText.Substring( _visibleTextStart, _visibleTextEnd - _visibleTextStart );
				graphics.Batcher.DrawString( font, t, new Vector2( x + bgLeftWidth + TextOffset, y + textY + yOffset ), col );
			}

			if( _isFocused && !_disabled )
			{
				Blink();
				if( _cursorOn && _style.Cursor != null )
					DrawCursor( _style.Cursor, graphics, font, x + bgLeftWidth, y + textY + yOffset );
			}
		}


		protected float GetTextY( BitmapFont font, IDrawable background )
		{
			float height = GetHeight();
			float textY = TextHeight / 2 + font.Descent;
			if( background != null )
			{
				var bottom = background.BottomHeight;
				textY = textY - ( height - background.TopHeight - bottom ) / 2 + bottom;
			}
			else
			{
				textY = textY - height / 2;
			}
				
			return textY;
		}


		/// <summary>
		/// Draws selection rectangle
		/// </summary>
		/// <param name="selection">Selection.</param>
		/// <param name="batch">Batch.</param>
		/// <param name="font">Font.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		protected void DrawSelection( IDrawable selection, Graphics graphics, BitmapFont font, float x, float y )
		{
			selection.Draw( graphics, x + _selectionX + _renderOffset + FontOffset, y - font.Descent / 2, _selectionWidth, TextHeight, Color.White );
		}


		protected void DrawCursor( IDrawable cursorPatch, Graphics graphics, BitmapFont font, float x, float y )
		{
			cursorPatch.Draw( graphics,
				x + TextOffset + _glyphPositions[Cursor] - _glyphPositions[_visibleTextStart] + FontOffset - 1 /*font.getData().cursorX*/,
				y - font.Descent / 2, cursorPatch.MinWidth, TextHeight, Color );
		}

		#endregion


		void UpdateDisplayText()
		{
			var textLength = Text.Length;

			_textBuffer.Clear();
			for( var i = 0; i < textLength; i++ )
			{
				var c = Text[i];
				_textBuffer.Append( _style.Font.HasCharacter( c ) ? c : ' ' );
			}
			var newDisplayText = _textBuffer.ToString();

			if( _passwordMode && _style.Font.HasCharacter( _passwordCharacter ) )
			{
				if( _passwordBuffer == null )
					_passwordBuffer = new StringBuilder( newDisplayText.Length );
				else if( _passwordBuffer.Length > textLength )
					_passwordBuffer.Clear();

				for( var i = _passwordBuffer.Length; i < textLength; i++ )
					_passwordBuffer.Append( _passwordCharacter );
				DisplayText = _passwordBuffer.ToString();
			}
			else
			{
				DisplayText = newDisplayText;
			}

			//layout.setText( font, displayText );
			_glyphPositions.Clear();
			float x = 0;
			if( DisplayText.Length > 0 )
			{
				for( var i = 0; i < DisplayText.Length; i++ )
				{
					var region = _style.Font.FontRegionForChar( DisplayText[i] );
					// we dont have fontOffset in BitmapFont, it is the first Glyph in a GlyphRun
					//if( i == 0 )
					//	fontOffset = region.xAdvance;
					_glyphPositions.Add( x );
					x += region.XAdvance;
				}
				//GlyphRun run = layout.runs.first();
				//FloatArray xAdvances = run.xAdvances;
				//fontOffset = xAdvances.first();
				//for( int i = 1, n = xAdvances.size; i < n; i++ )
				//{
				//	glyphPositions.add( x );
				//	x += xAdvances.get( i );
				//}
			}
			else
			{
				FontOffset = 0;
			}
			_glyphPositions.Add( x );

			if( SelectionStart > newDisplayText.Length )
				SelectionStart = textLength;
		}


		void Blink()
		{
			if( ( Time.time - _lastBlink ) > _blinkTime )
			{
				_cursorOn = !_cursorOn;
				_lastBlink = Time.time;
			}
		}


		#region Text manipulation

		/// <summary>
		/// Copies the contents of this TextField to the {@link Clipboard} implementation set on this TextField
		/// </summary>
		public void Copy()
		{
			if( HasSelection && !_passwordMode )
			{
				var start = Math.Min( Cursor, SelectionStart );
				var length = Math.Max( Cursor, SelectionStart ) - start;
				Clipboard.SetContents( Text.Substring( start, length ) );
			}
		}


		/// <summary>
		/// Copies the selected contents of this TextField to the {@link Clipboard} implementation set on this TextField, then removes it
		/// </summary>
		public void Cut()
		{
			Cut( _programmaticChangeEvents );
		}


		void Cut( bool fireChangeEvent )
		{
			if( HasSelection && !_passwordMode )
			{
				Copy();
				Cursor = Delete( fireChangeEvent );
				UpdateDisplayText();
			}
		}


		void Paste( string content, bool fireChangeEvent )
		{
			if( content == null )
				return;

			_textBuffer.Clear();
			int textLength = Text.Length;
			if( HasSelection )
				textLength -= Math.Abs( Cursor - SelectionStart );
			
			//var data = style.font.getData();
			for( int i = 0, n = content.Length; i < n; i++ )
			{
				if( !WithinMaxLength( textLength + _textBuffer.Length ) )
					break;

				var c = content[i];
				if( !( WriteEnters && c == '\r' ) )
				{
					if( _onlyFontChars && !_style.Font.HasCharacter( c ) )
						continue;
					
					if( _filter != null && !_filter.AcceptChar( this, c ) )
						continue;
				}

				_textBuffer.Append( c );
			}
			content = _textBuffer.ToString();

			if( HasSelection )
				Cursor = Delete( fireChangeEvent );
			if( fireChangeEvent )
				ChangeText( Text, Insert( Cursor, content, Text ) );
			else
				Text = Insert( Cursor, content, Text );
			UpdateDisplayText();
			Cursor += content.Length;
		}


		string Insert( int position, string text, string to )
		{
			if( to.Length == 0 )
				return text;
			return to.Substring( 0, position ) + text + to.Substring( position, to.Length - position );
		}


		int Delete( bool fireChangeEvent )
		{
			var from = SelectionStart;
			var to = Cursor;
			var minIndex = Math.Min( from, to );
			var maxIndex = Math.Max( from, to );
			var newText = ( minIndex > 0 ? Text.Substring( 0, minIndex ) : "" )
						  + ( maxIndex < Text.Length ? Text.Substring( maxIndex, Text.Length - maxIndex ) : "" );
			
			if( fireChangeEvent )
				ChangeText( Text, newText );
			else
				Text = newText;

			ClearSelection();
			return minIndex;
		}


		/// <summary>
		/// Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage
		/// up: If true, the TextField with the same or next smallest y coordinate is found, else the next highest.
		/// </summary>
		/// <param name="up">Up.</param>
		public void Next( bool up )
		{
			var stage = GetStage();
			if( stage == null )
				return;

			var tmp2 = Vector2.Zero;
			var tmp1 = GetParent().LocalToStageCoordinates( new Vector2( GetX(), GetY() ) );
			var textField = FindNextTextField( stage.GetElements(), null, tmp2, tmp1, up );
			if( textField == null )
			{
				// Try to wrap around.
				if( up )
					tmp1 = new Vector2( float.MinValue, float.MinValue );
				else
					tmp1 = new Vector2( float.MaxValue, float.MaxValue );
				textField = FindNextTextField( GetStage().GetElements(), null, tmp2, tmp1, up );
			}

			if( textField != null )
				stage.SetKeyboardFocus( textField );
		}


		TextField FindNextTextField( List<Element> elements, TextField best, Vector2 bestCoords, Vector2 currentCoords, bool up )
		{
			bestCoords = Vector2.Zero;
			for( int i = 0, n = elements.Count; i < n; i++ )
			{
				var element = elements[i];
				if( element == this )
					continue;
				
				if( element is TextField )
				{
					var textField = (TextField)element;
					if( textField.IsDisabled() || !textField._focusTraversal )
						continue;
					
					var elementCoords = element.GetParent().LocalToStageCoordinates( new Vector2( element.GetX(), element.GetY() ) );
					if( ( elementCoords.Y < currentCoords.Y || ( elementCoords.Y == currentCoords.Y && elementCoords.X > currentCoords.X ) ) ^ up )
					{
						if( best == null
							|| ( elementCoords.Y > bestCoords.Y || ( elementCoords.Y == bestCoords.Y && elementCoords.X < bestCoords.X ) ) ^ up )
						{
							best = (TextField)element;
							bestCoords = elementCoords;
						}
					}
				}
				else if( element is Group )
				{
					best = FindNextTextField( ( (Group)element ).GetChildren(), best, bestCoords, currentCoords, up );
				}
			}

			return best;
		}


		#endregion


		/// <summary>
		/// if str is null, "" is used
		/// </summary>
		/// <param name="str">String.</param>
		public void AppendText( string str )
		{
			if( ShouldIgnoreTextUpdatesWhileFocused && _isFocused )
				return;
			
			if( str == null )
				str = "";

			ClearSelection();
			Cursor = Text.Length;
			Paste( str, _programmaticChangeEvents );
		}


		/// <summary>
		/// str If null, "" is used
		/// </summary>
		/// <param name="str">String.</param>
		public TextField SetText( string str )
		{
			if( ShouldIgnoreTextUpdatesWhileFocused && _isFocused )
				return this;
			
			if( str == null )
				str = "";
			if( str == Text )
				return this;

			ClearSelection();
			var oldText = Text;
			Text = "";
			Paste( str, false );
			if( _programmaticChangeEvents )
				ChangeText( oldText, Text );
			Cursor = 0;

			return this;
		}


		/// <summary>
		/// force sets the text without validating or firing change events. Use at your own risk.
		/// </summary>
		/// <param name="str">String.</param>
		public TextField SetTextForced( string str )
		{
			Text = str;
			UpdateDisplayText();

			// ensure our cursor is in bounds
			Cursor = Text.Length;

			return this;
		}


		/// <summary>
		/// Never null, might be an empty string
		/// </summary>
		/// <returns>The text.</returns>
		public string GetText()
		{
			return Text;
		}


		/// <summary>
		/// oldText May be null
		/// </summary>
		/// <param name="oldText">Old text.</param>
		/// <param name="newText">New text.</param>
		void ChangeText( string oldText, string newText )
		{
			if( newText == oldText )
				return;
			Text = newText;

			if( OnTextChanged != null )
				OnTextChanged( this, Text );
		}


		/// <summary>
		/// If false, methods that change the text will not fire {@link onTextChanged}, the event will be fired only when user changes the text
		/// </summary>
		/// <param name="programmaticChangeEvents">If set to <c>true</c> programmatic change events.</param>
		public TextField SetProgrammaticChangeEvents( bool programmaticChangeEvents )
		{
			this._programmaticChangeEvents = programmaticChangeEvents;
			return this;
		}


		public int GetSelectionStart()
		{
			return SelectionStart;
		}


		public string GetSelection()
		{
			return HasSelection ? Text.Substring( Math.Min( SelectionStart, Cursor ), Math.Max( SelectionStart, Cursor ) ) : "";
		}


		/// <summary>
		/// Sets the selected text
		/// </summary>
		/// <param name="selectionStart">Selection start.</param>
		/// <param name="selectionEnd">Selection end.</param>
		public TextField SetSelection( int selectionStart, int selectionEnd )
		{
			Assert.IsFalse( selectionStart < 0, "selectionStart must be >= 0" );
			Assert.IsFalse( selectionEnd < 0, "selectionEnd must be >= 0" );

			selectionStart = Math.Min( Text.Length, selectionStart );
			selectionEnd = Math.Min( Text.Length, selectionEnd );
			if( selectionEnd == selectionStart )
			{
				ClearSelection();
				return this;
			}

			if( selectionEnd < selectionStart )
			{
				int temp = selectionEnd;
				selectionEnd = selectionStart;
				selectionStart = temp;
			}

			HasSelection = true;
			this.SelectionStart = selectionStart;
			Cursor = selectionEnd;

			return this;
		}


		public void SelectAll()
		{
			SetSelection( 0, Text.Length );
		}


		public void ClearSelection()
		{
			HasSelection = false;
		}


		protected void SetCursorPosition( float x, float y )
		{
			_lastBlink = 0;
			_cursorOn = false;
			Cursor = LetterUnderCursor( x );
		}


		/// <summary>
		/// Sets the cursor position and clears any selection
		/// </summary>
		/// <param name="cursorPosition">Cursor position.</param>
		public TextField SetCursorPosition( int cursorPosition )
		{
			Assert.IsFalse( cursorPosition < 0, "cursorPosition must be >= 0" );
			ClearSelection();
			Cursor = Math.Min( cursorPosition, Text.Length );
			return this;
		}


		public int GetCursorPosition()
		{
			return Cursor;
		}


		protected void GoHome()
		{
			Cursor = 0;
		}


		protected void GoEnd()
		{
			Cursor = Text.Length;
		}


		protected void MoveCursor( bool forward, bool jump )
		{
			var limit = forward ? Text.Length : 0;
			var charOffset = forward ? 0 : -1;

			if( ( forward && Cursor == limit ) || ( !forward && Cursor == 0 ) )
				return;

			while( ( forward ? ++Cursor < limit : --Cursor > limit ) && jump )
			{
				if( !ContinueCursor( Cursor, charOffset ) )
					break;
			}
		}


		protected bool ContinueCursor( int index, int offset )
		{
			var c = Text[index + offset];
			return IsWordCharacter( c );
		}


		#region Configuration

		public TextField SetPreferredWidth( float preferredWidth )
		{
			_preferredWidth = preferredWidth;
			return this;
		}


		/// <summary>
		/// filter May be null
		/// </summary>
		/// <param name="filter">Filter.</param>
		public TextField SetTextFieldFilter( ITextFieldFilter filter )
		{
			this._filter = filter;
			return this;
		}


		public ITextFieldFilter GetTextFieldFilter()
		{
			return _filter;
		}


		/// <summary>
		/// If true (the default), tab/shift+tab will move to the next text field
		/// </summary>
		/// <param name="focusTraversal">If set to <c>true</c> focus traversal.</param>
		public TextField SetFocusTraversal( bool focusTraversal )
		{
			this._focusTraversal = focusTraversal;
			return this;
		}


		/// <summary>
		/// May be null
		/// </summary>
		/// <returns>The message text.</returns>
		public string GetMessageText()
		{
			return _messageText;
		}


		/// <summary>
		/// Sets the text that will be drawn in the text field if no text has been entered.
		/// </summary>
		/// <param name="messageText">Message text.</param>
		public TextField SetMessageText( string messageText )
		{
			this._messageText = messageText;
			return this;
		}


		/// <summary>
		/// Sets text horizontal alignment (left, center or right).
		/// </summary>
		/// <param name="alignment">Alignment.</param>
		public TextField SetAlignment( Align alignment )
		{
			this._textHAlign = (int)alignment;
			return this;
		}


		/// <summary>
		/// If true, the text in this text field will be shown as bullet characters.
		/// </summary>
		/// <param name="passwordMode">Password mode.</param>
		public TextField SetPasswordMode( bool passwordMode )
		{
			this._passwordMode = passwordMode;
			UpdateDisplayText();
			return this;
		}


		public bool IsPasswordMode()
		{
			return _passwordMode;
		}


		/// <summary>
		/// Sets the password character for the text field. The character must be present in the {@link BitmapFont}. Default is 149 (bullet)
		/// </summary>
		/// <param name="passwordCharacter">Password character.</param>
		public TextField SetPasswordCharacter( char passwordCharacter )
		{
			this._passwordCharacter = passwordCharacter;
			if( _passwordMode )
				UpdateDisplayText();
			return this;
		}


		public TextField SetBlinkTime( float blinkTime )
		{
			this._blinkTime = blinkTime;
			return this;
		}


		public TextField SetDisabled( bool disabled )
		{
			this._disabled = disabled;
			return this;
		}


		public bool IsDisabled()
		{
			return _disabled;
		}

		#endregion


		/// <summary>
		/// Interface for filtering characters entered into the text field.
		/// </summary>
		public interface ITextFieldFilter
		{
			bool AcceptChar( TextField textField, char c );
		}
	}


	public class TextFieldStyle
	{
		public BitmapFont Font;
		public Color FontColor = Color.White;
		/** Optional. */
		public Color? FocusedFontColor, DisabledFontColor;
		/** Optional. */
		public IDrawable Background, FocusedBackground, DisabledBackground, Cursor, Selection;
		/** Optional. */
		public BitmapFont MessageFont;
		/** Optional. */
		public Color? MessageFontColor;


		public TextFieldStyle()
		{
			Font = Graphics.Instance.BitmapFont;
		}


		public TextFieldStyle( BitmapFont font, Color fontColor, IDrawable cursor, IDrawable selection, IDrawable background )
		{
			this.Background = background;
			this.Cursor = cursor;
			this.Font = font ?? Graphics.Instance.BitmapFont;
			this.FontColor = fontColor;
			this.Selection = selection;
		}


		public static TextFieldStyle Create( Color fontColor, Color cursorColor, Color selectionColor, Color backgroundColor )
		{
			var cursor = new PrimitiveDrawable( cursorColor );
			cursor.MinWidth = 1;
			cursor.LeftWidth = 4;

			var background = new PrimitiveDrawable( backgroundColor );
			background.LeftWidth = background.RightWidth = 10f;
			background.BottomHeight = background.TopHeight = 5f;

			return new TextFieldStyle {
				FontColor = fontColor,
				Cursor = cursor,
				Selection = new PrimitiveDrawable( selectionColor ),
				Background = background
			};
		}
	

		public TextFieldStyle Clone()
		{
			return new TextFieldStyle {
				Font = Font,
				FontColor = FontColor,
				FocusedFontColor = FocusedFontColor,
				DisabledFontColor = DisabledFontColor,
				Background = Background,
				FocusedBackground = FocusedBackground,
				DisabledBackground = DisabledBackground,
				Cursor = Cursor,
				Selection = Selection,
				MessageFont = MessageFont,
				MessageFontColor = MessageFontColor
			};
		}
	}


	public class DigitsOnlyFilter : TextField.ITextFieldFilter
	{
		public bool AcceptChar( TextField textField, char c )
		{
			return Char.IsDigit( c ) || c == '-';
		}
	}


	public class FloatFilter : TextField.ITextFieldFilter
	{
		public bool AcceptChar( TextField textField, char c )
		{
			// only allow one .
			if( c == '.' )
				return !textField.GetText().Contains( "." );
			return Char.IsDigit( c ) || c == '-';
		}
	}


	public class BoolFilter : TextField.ITextFieldFilter
	{
		public bool AcceptChar( TextField textField, char c )
		{
			if( c == 't' || c == 'T' )
				textField.SetTextForced( "true" );

			if( c == 'f' || c == 'F' )
				textField.SetTextForced( "false" );

			return false;
		}
	}

}

